# 计算机网络

### HTTP特点

* 无状态
* 无连接
* 基于请求和响应
* 简单快速、灵活
* 通信使用明文，无法保证数据完整性

### HTTPS特点

* 基于HTTP协议，通过SSL或TLS加密
* 内容加密
* 验证身份
* 保护数据完整性



> - http 协议的`默认端口`为 80，https 的默认端口为 443。

***

### HTTP数据包结构与细节

##### 请求报文

* 请求行  请求方式（GET）+ 请求资源（URL）+ 协议版本（HTTP/1.1）
* 请求头 
  * 用来说明服务器要使用的附加信息（一些键值对）
  * 例如：User-Agent、 Accept、Content-Type、Connection
* 空行
* 请求体  任意的其他数据

##### 响应报文

- 状态行
  - 状态码
  - 状态消息
  - HTTP协议版本号
- 消息报头
  - 说明客户端要使用的一些附加信息
  - 如：Content-Type、charset、响应的时间
- 响应正文
  - 返回给客户端的文本信息

***

### 常见的状态码

* 1XX 指示信息      **表示请求已接收，继续处理**
* 2XX 成功
  * **200** OK
  * 204 No content，表示请求成功，但响应报文不含实体的主体部分
  * 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
  * **206** Partial Content，进行范围请求

* 3XX 重定向
  * **301** 永久性重定向，表示资源已被分配了新的 URL
  * **302** 临时性重定向，表示资源临时被分配了新的 URL
  * 303 表示资源存在着另一个 URL，应使用 GET 方法获取资源
  * **304** 资源未修改，重定位到浏览器。自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
  * 307 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

* 4XX 客户端错误
  * **404** 在服务器上没有找到请求的资源
  * **403** forbidden，表示对请求资源的访问被服务器拒绝
  * 400 请求报文存在语法错误
  * 401 表示发送的请求需要有通过 HTTP 认证的认证信息

* 5XX 服务器错误
  * **500** 表示服务器端在执行请求时发生了错误
  * 501 表示服务器不支持当前请求所需要的某个功能
  * **503** 表明服务器暂时处于超负载或正在停机维护，无法处理请求

***

### HTTP 方法

- GET   获取资源
- POST  传输资源
- PUT   更新资源
- DELETE   删除资源
- HEAD     获取报文首部



### 副作用与幂等

* 副作用：指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

* 幂等：指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

> 在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。



### HTTP持久连接（HTTP1.1支持）

HTTP协议采用“请求-应答”模式，并且HTTP是基于TCP进行连接的。普通模式（非keep-alive）时，每个请求或应答都需要建立一个连接，完成之后立即断开。

当使用`Conection: keep-alive`模式（又称持久连接、连接重用）时，keep-alive使客户端道服务器端连接持续有效，即不关闭底层的TCP连接，当出现对服务器的后继请求时，keep-alive功能避免重新建立连接。



### HTTP管线化

管线化后，请求和响应不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。

- 只有get与head请求可以进行管线化，POST有限制
- 初次创建连接时不应该启动管线机制，因为服务器不一定支持该协议



### HTTP数据协商

在客户端向服务端发送请求的时候，客户端会申明可以接受的数据格式和数据相关的一些限制是什么样的；服务端在接受到这个请求时他会根据这个信息进行判断到底返回怎样的数据。

**请求**

- cookie
- Host
- Connection
- Accept
  - 在请求中使用Accept可申明想要的数据格式(image/webp,image/apng,image/)
- Accept-Encoding
  - 告诉服务端使用什么的方式来进行压缩
  - 例如：gzip、deflate、br
- Accept-Language
  - 描述语言信息(zh-CN)
- User-Agent(Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.15 Safari/537.36)
  - 用来描述客户端浏览器相关信息
  - 可以用来区分PC端页面和移动端页面

**响应**

- Content-Type
  - 对应Accept，从请求中的Accept支持的数据格式中选一种来返回
- Content-Encoding
  - 对应 Accept-Encoding，指服务端到底使用的是那种压缩方式
- Content-Language
  - 对应Accept-Language

 **form 表单中enctype数据类型**

- ```
  application/x-www-form-urlencoded
  ```

  - key=value&key=value 格式

- ```
  multipart/form-data
  ```

  - 用于提交文件
  - multipart表示请求是由多个部分组成（因为上传文件的时候文件不能以字符串形式提交，需要单独分出来）
  - boundary 用来分隔不同部分

- `text/plain`



### HTTP缓存机制

1. 作用
   * 提高资源加载速度
   * 减少网络请求，提高页面渲染速度

2. 分类
   * http缓存
   * 数据缓存

3. HTTP缓存

4. 强缓存

   不请求服务器，直接用，返回状态码200

- Pragma
  包括实现特定的指令，它可应用到响应链上的的任何接收方
  `no-cache`
  指定不缓存响应，即资源不缓存；
  不直接询问浏览器缓存情况，向服务器验证当前资源是否更新，因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。
  `no-store`
  绝对缓存,每次请求都会请求服务端
- Cache-Control
  显示是否可以缓存及其缓存类型
  `max-age&s-maxage`
  `max-age`（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当第一次访问服务器的时候，返回一个max-age，在max-age这段时间内，客户端不会在访问服务器获取该资源。
  `s-maxage`用于共享缓存（比如CDN）,s-maxage也叫代理缓存，优先级高于max-age
  `public&private`
  `public`表示该资源可以被多个用户共享，当没有指定public还是private的时候，默认是public
  `private`响应只作为私有的缓存，不能在用户间共享，如果要求认证，响应会自动设置为private
  `no-cache&no-store`
  `no-cache`
  指定不缓存响应，即资源不缓存；
  不直接询问浏览器缓存情况，向服务器验证当前资源是否更新，因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。
  no-store
  绝对缓存,每次请求都会请求服务端
- Expires
  响应过期的日期和时间（服务器的绝对时间）
  Expires是一个时间戳，当客户端再次请求资源的时候，会吧客户端的时间与时间戳相比，如果过期了，则会访问服务端的资源，不会访问缓存资源

1. 协商缓存

   - 请求服务器，服务器同意了才用，返回状态码304
     当浏览器检测某个资源请求没有强缓存，就会发起一个请求到服务器，验证是否存在协商缓存，如果存在协商缓存就回家返回http状态为304，并且会显示一个not modified的字符串
     协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的
   - last-Modified
     服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。
   - ETag
     ETag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的;可以理解为ETag是一个可以与Web资源关联的记号（token）
     If-None-Match的header会将上次返回的ETag发送给服务器，询问该资源的ETag是否有更新，有变动就会发送新的资源回来；如果ETag没有变动，则返回状态码304



### 浏览器的缓存机制 强制缓存 && 协商缓存

浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-watermark.awebp)

由上图我们可以知道：

- 浏览器每次发起请求，都会`先在浏览器缓存中查找该请求的结果以及缓存标识`
- 浏览器每次拿到返回的请求结果都会`将该结果和缓存标识存入浏览器缓存中`

以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是`强制缓存`和`协商缓存`。

- **强制缓存**

  `强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。`当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中Cache-Control优先级比Expires高。

  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

  1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
  2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
  3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

- **协商缓存**

  `协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程`，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：

  1. 协商缓存生效，返回304
  2. 协商缓存失效，返回200和请求结果结果



***

### 跨域问题

**原因：浏览器同源策略** ： 1. 针对接口的请求  2. 针对DOM的查询

* 协议
* 域名
* 端口

##### 解决方案



***

### CSFR攻击

　CSRF（Cross-site request forgery）跨站请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

##### 解决

1. 网关微服务配置CORS拦截器

***

### XSS攻击

XSS 全称(Cross Site Scripting) 跨站脚本攻击， 是Web程序中最常见的漏洞。指攻击者在网页中嵌入客户端脚本 (例如JavaScript) , 当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.。比如获取用户的Cookie，导航到恶意网站,携带木马等。

##### 解决

1. 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了.
2. 只允许用户输入我们期望的数据。 例如：年龄的textbox中，只允许用户输入数字。 而数字之外的字符都过滤掉。
3. 对数据进行Html Encode 处理。将其中的"中括号"， “单引号”，“引号” 之类的特殊字符进行编码。
4. 过滤或移除特殊的Html标签。

***

### HTTP2

**大幅提升性能**

在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是**因为浏览器限制了同一个域名下的请求数量**，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

* **二进制传输**

  HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

* **多路复用**

  在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

  帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

  **多路复用，就是在一个 TCP 连接中可以存在多条流。**换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

* Header压缩

  在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

  在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

* 服务端Push

  在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。

  可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。

***

### 一个页面的诞生

1. URL解析
2. DNS解析
3. 浏览器主机根据ip地址与服务器建立TCP连接  **三次握手**
4. 发送HTTP请求
5. 服务器处理请求并返回HTTP报文
6. 断开TCP连接  **四次挥手**
7. 浏览器解析文件
8. 浏览器布局渲染

[(142条消息) 在浏览器地址栏输入URL之后发生了什么？_CH-EN.的博客-CSDN博客_在地址栏输入url后发生了什么](https://blog.csdn.net/xciyi/article/details/120778578)



#### URL

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。

```
scheme: // host.domain:port / path / filename ? abc = 123 # 456789

scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，
               其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host         - 定义域主机（http 的默认主机是 www）
domain       - 定义因特网域名，比如 baidu.com
port         - 定义主机上的端口号（http 的默认端口号是 80）
path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename     - 定义文档/资源的名称
query        - 即查询参数
fragment     - 即 # 后的hash值，一般用来定位到某个位置
```

##### DNS

* IP 地址

  IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个**逻辑地址，**以此来屏蔽物理地址的差异。

* 域名解析

  DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。

> DNS服务器是基于UDP的，因此会用到UDP协议

**DNS的优化与应用**

1. DNS缓存 `DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。`

2. DNS负载均衡`(DNS重定向) DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。`

   > 大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。

3. dns-prefetch `DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。`

***

### OSI参考模型

1. 物理层  以太网
2. 数据链路层  双绞线光纤
3. 网络层   IPv4、IPv6
4. 传输层   TCP、UDP
5. 会话层  
6. 表示层
7. 应用层

***

### TCP三次握手

1. 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口`（第一次握手，由浏览器发起，告诉服务器我要发送请求了）`

   > SYN：同步序列编号（Synchronize Sequence Numbers）。

2. 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息`（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）`

3. 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”`（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）`

***

### TCP 四次挥手

1. `客户端进程发出连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，`客户端进入FIN-WAIT-1（终止等待1）状态`。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. `服务器收到连接释放报文，发出确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，`服务端就进入了CLOSE-WAIT（关闭等待）状态`。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，`客户端就进入FIN-WAIT-2（终止等待2）状态`，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
4. `服务器将最后的数据发送完毕后，就向客户端发送连接释放报文`，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，`服务器就进入了LAST-ACK（最后确认）状态`，等待客户端的确认。
5. `客户端收到服务器的连接释放报文后，必须发出确认`，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，`客户端就进入了TIME-WAIT（时间等待）状态`。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，`当客户端撤销相应的TCB后，才进入CLOSED状态`。
6. 服务器只要收到了客户端发出的确认，`立即进入CLOSED状态`。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，`服务器结束TCP连接的时间要比客户端早一些`。

***

### TCP和UDP的区别

1. TCP是面向`链接`的，而UDP是面向无连接的。
2. TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。
3. TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。
4. UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。

***

### 粘包问题分析与对策

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

**粘包出现原因**

简单得说，在流传输中出现，UDP不会出现粘包，因为它有**消息边界**

粘包情况有两种，一种是`粘在一起的包都是完整的数据包`，另一种情况是`粘在一起的包有不完整的包`。

为了**避免粘包**现象，可采取以下几种措施：

（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，`TCP提供了强制数据立即传送的操作指令push`，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；

（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、`提高接收进程优先级等措施`，使其及时接收数据，从而尽量避免出现粘包现象；

（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。`分包多发`。

以上提到的三种措施，都有其不足之处。

（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。

（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。

（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

> 一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。







### 说下进程、线程和协程

**进程**是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，`是操作系统进行资源分配和调度的一个独立单位`，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

**线程**是程序执行中一个单一的顺序控制流程，是`程序执行流的最小单元`，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

**协程**，英文Coroutines，是一种`基于线程之上，但又比线程更加轻量级的存在`，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

**进程和线程的区别与联系**

* 区别
  * 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
  *  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；
  *  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
  *  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
* 联系：
  *  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
  *  资源分配给进程，同一进程的所有线程共享该进程的所有资源；
  *  处理机分给线程，即真正在处理机上运行的是线程；
  *  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

***

### **HTTP1.1 的缺陷**

[解读 HTTP1/HTTP2/HTTP3 ](https://juejin.cn/post/6995109407545622542)

1. 高延迟 — 队头阻塞(Head-Of-Line Blocking) 

2. 无状态特性 — 阻碍交互 

   > 带来巨大的HTTP头部

3. 明文传输 — 不安全性

4. 不支持服务端推送



### HTTP/2 新特性

1. 二进制传输
2. Header 压缩
3. 多路复用
4. Server Push
5. 提高安全性



### HTTP/2 的缺点

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，**主要是底层支撑的 TCP 协议造成的**。HTTP/2的缺点主要有以下几点：

1. 建立连接的时间增加   **TCP握手**

2. 队头阻塞没有彻底解决

   为TCP为了保证可靠传输，有个特别的“`丢包重传`”机制，`丢失的包必须要等待重新传输确认`，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求

3. 多路复用导致服务器压力上升

4. 多路复用容易 Timeout



### HTTP/3 新特性

1. 让HTTP跑在QUIC（UDP）上而不是TCP上  **实现快速握手**
2. “完美”地解决了“队头阻塞”问题

***

